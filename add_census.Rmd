---
title: "Combining Census data with the Same Sex Marriage Survey in R"
author: "Miles McBain"
date: "November 25, 2017"
output: html_document
---

# Load SSM data

```{r}
library(readr)
ssm_response <- read_csv("./SSM_AUS_Response.csv") %>%  
  mutate(State = gsub("TAS", "Tas.", State))
ssm_participation <- read_csv("./SSM_AUS_Participation.csv")

```

# Get Census Data
Ignore all the reports and go straight for the 'datapacks' at https://datapacks.censusdata.abs.gov.au/datapacks/. These are geographically summarised views of the data. To get data there are two choices to be made regarding the how the summaries are produced:
1. 'Type' which concerns questions like: do you want to summarise by people's place of residence or by place where they filled out the census form? For a postal survey we want the the data summarised by place of residence which is the 'General Community Profile' datapack. 

1. Geographical area used for summarise. To match the postal survey data I chose 'Commonwealth Electoral Divisions'.

If you'd prefer not to do this you can use my [`fetch_data.R` script](https://github.com/MilesMcBain/aus_ssm_census/blob/master/fetch_data.R) to fetch and decompress the datapack to `./data`.

# Navigating the Data Pack
The datapack consists of 59 encoded csv files and 3 metadata excel files that will help us decode their meaning. What? You didn't think this was going to be straight forward did you? When I say encoded, I mean the csv's have inscrutable names like `2016Census_G09C.csv` and contain column names like `Se_d_r_or_t_h_t_Tot_NofB_0_ib` (H.T. @hughparsonage).

Two of the metadata files in `./data/Metadata/` have useful applications for us: `2016Census_geog_desc_1st_and_2nd_release.xlsx` will help us resolve encoded geographic areas to federal electorate names. `Metadata_2016_GCP_DataPack.xlsx` lists the topics of each of the 59 tables and will allow us to replace a short and uninformative column name with a much longer, and slightly more informative name. These can be read without too much hassle:


```{r}
library(readxl)
electorate_codes <- read_excel(
  path = "./data/Metadata/2016Census_geog_desc_1st_and_2nd_release.xlsx",
  sheet = "2016_ASGS_Non-ABS_Structures")

column_codes <- read_excel(
  path = "./data/Metadata/Metadata_2016_GCP_DataPack.xlsx",
  sheet = "Cell descriptors information",
  skip = 10)
```

# Religious Affiliation
Suppose we are interested in reproducing [This Guardian article](https://www.theguardian.com/australia-news/datablog/2017/nov/17/same-sex-marriage-survey-religion-drove-the-no-vote)'s analysis of the correlation between percentage of religious people and percentage No votes.  The first step is to identify the datapack table that contains religious affiliation data. If we look at sheet two of `Metadata_2016_GCP_DataPack.xlsx` we can see a likely choice is table 'G14':
![](religious_info.png)

Next I read in the table and replace the short column names with the long ones to help makes sense of the table. This is indicitive what we're working with:
```
# A tibble: 168 x 103
   CED_CODE_2016 Buddhism_Males Buddhism_Females Buddhism_Persons
           <chr>          <int>            <int>            <int>
 1        CED101           2766             3921             6687
 2        CED102           3764             5078             8849
 3        CED103           3136             4200             7337
 4        CED104           1718             2240             3953
 5        CED105           6508             7815            14323
 6        CED106           2043             3012             5061
 7        CED107            399              573              971
 8        CED108           1092             1222             2312
 9        CED109            789             1224             2017
10        CED110            611              878             1491
# ... with 158 more rows, and 99 more variables:
#   Christianity_Anglican_Males <int>,
#   Christianity_Anglican_Females <int>,
#   Christianity_Anglican_Persons <int>,
#   Christianity_Assyrian_Apostolic_Males <int>,
#   Christianity_Assyrian_Apostolic_Females <int>,
...
#   Christianity_Total_Persons <int>, Hinduism_Males <int>,
#   Hinduism_Females <int>, Hinduism_Persons <int>, Islam_Males <int>,
#   Islam_Females <int>, Islam_Persons <int>, Judaism_Males <int>,
...

```
Notice how the records are keyed by `CED_CODE_2016` which stands for Commonwealth Electoral Division. The next step is to update the columns of G14 with their more expressive long names. We are going append these columns to our response data. Unfortuately we do not have a common key to join these tables with, so there is an intermediate step to join the CED code to the response data from `electoral_codes`. 

Once the regligous affiliation data are appeneded to the correct electorate row, we calculate a new variable representing the proportion of religious people: `prop_christian_and_islamic`. I singled out these because they are are Australia's top two and I am aware of anti-same sex marriage stances within both. Take a look at the code before some more detailed commentary:

```{r}
library(tidyverse)

religious_affiliation_by_person <-
  read_csv(
    file = "data/2016 Census GCP Commonwealth Electoral Divisions for AUST/2016Census_G14_AUS_CED.csv")

short_to_long_names <- function(a_dataframe, short_names, long_names){
  short_name_match_idx <- match(names(a_dataframe), short_names)
  names_with_match <- !is.na(short_name_match_idx)
  names(a_dataframe)[names_with_match] <- long_names[short_name_match_idx[names_with_match]]
  a_dataframe
}

religious_affiliation_by_person <- 
  short_to_long_names(religious_affiliation_by_person, column_codes$Short, column_codes$Long)

religion_vs_no <- 
  ssm_response %>%
  left_join(electorate_codes, by = c("area" = "Census_Name_2016")) %>%
  filter(ASGS_Structure == "CED") %>%
  left_join(religious_affiliation_by_person, by = c("Census_Code_2016" = "CED_CODE_2016")) %>%
  mutate(prop_christian_and_muslim = ((Christianity_Total_Persons + Islam_Persons)/Total_Persons)*100 ) %>%
  select(area, prop_christian_and_islamic, `No pct`, State)

```

I wrote a function to replace the short with long names for 2 reasons: it was a fiddly task and knew I would need to repeat it. Compare the code for that function with my original one liner: `names(religious_affiliation_by_person)[-1] <- column_codes$Long[match(names(religious_affiliation_by_person), column_codes$Short)[-1]]`

Yuck! 

## On performing joins
I'd like to spend a minute discussing joins. There is really only one join you need for > 90% of cases and that is the left join. The reason you want the left join is that when you arrange your tables properly you can use the presence of `NA` as a litmus test for problems relating to data mismatches. Inner joins will silently filter mismatches which is just plain scary! Imagine loosing rows of data because dumb join code coudln't resolve that "QLD" and "Qld" actually refer to the same state.

So how to arrange your tables in left joins to maximise our ability to detect problems? The rule of thumb I suggest is from subset to superset (effectively smallest to largest). Think about about it: If I left join a subset (statewise survey responses) to a superset  


## A plot
```{r}
library(ggplot2)
religion_vs_no %>%
  ggplot(aes(x = `No pct`, y = prop_christian_and_islamic, colour= State, label = area)) +
  geom_point() +
  facet_wrap(~State) +
  theme(legend.position = "none")
```


# Won't Somebody Think of the Children
```{r}
family_composition <- 
  read_csv("data/2016 Census GCP Commonwealth Electoral Divisions for AUST/2016Census_G25_AUS_CED.csv")

family_composition <-  
  short_to_long_names(family_composition, column_codes$Short, column_codes$Long)

families_with_young_children_vs_no <-
  ssm_response %>%
  left_join(electorate_codes, by = c("area" = "Census_Name_2016")) %>%
  filter(ASGS_Structure == "CED") %>%
  left_join(family_composition, by = c("Census_Code_2016" = "CED_CODE_2016")) %>%
  mutate(pct_young_children = (Couple_family_with_children_under_15_and_no_dependent_students_and_no_non_dependent_children_Persons/Total_Persons)*100) %>%
  select(area, pct_young_children, `No pct`, State)

families_with_young_children_vs_no %>%
  ggplot(aes(x = pct_young_children, y = `No pct`)) +
  geom_point() + 
  facet_wrap(~State)

```


